
module HelperSubroutines
contains
    !
    ! Helper method to generate a very naive "hash".
    !
    subroutine generate_hash(n, y, hash)
        implicit none
        integer, intent(in) :: n
        real, intent(in)    :: y(:)
        real, intent(out)   :: hash
        integer             :: i
        
        hash = sum(y)
    end subroutine generate_hash
    
    !
    ! SAXPY reference implementation using the CPU.
    !
    subroutine cpu_saxpy(n, a, x, y)
        implicit none
        integer, intent(in) :: n
        real, intent(in)    :: a
        real, intent(in)    :: x(:)
        real, intent(inout) :: y(:)
        integer             :: i
        
        y = a * x + y
    end subroutine cpu_saxpy
end module HelperSubroutines

module CUDAKernels
contains
    !
    ! SAXPY implementation using the GPU.
    !
    attributes(global) subroutine gpu_saxpy(n, a, d_x, d_y)
        implicit none
        integer, value      :: n
        real, value         :: a
        real, intent(in)    :: d_x(:)
        real, intent(inout) :: d_y(:)
        integer             :: i
        
        i = (blockIdx%x - 1) * blockDim%x + threadIdx%x
        
        if (i <= n) then
            d_y(i) = a * d_x(i) + d_y(i)
        end if
    end subroutine gpu_saxpy 
end module CUDAKernels

program lab01_ex2
    use HelperSubroutines
    use CUDAKernels
    use cudafor
    implicit none
    integer, parameter        :: BLOCK_SIZE = 256
    integer, parameter        :: ARRAY_SIZE = 16777216
    integer                   :: argc
    character(len=21)         :: argv
    real                      :: a
    real, allocatable         :: x(:)
    real, allocatable         :: y(:)
    real, allocatable, device :: d_x(:)
    real, allocatable, device :: d_y(:)
    real                      :: error
    real                      :: error_gpu
    integer                   :: hr
    type(dim3) :: grid
    type(dim3) :: block
    
    grid  = dim3(((ARRAY_SIZE + (BLOCK_SIZE - 1)) / BLOCK_SIZE), 1, 1)
    block = dim3(BLOCK_SIZE, 1, 1)
    
    ! Make sure the constant is provided
    argc = command_argument_count()
    if(argc /= 1) then
        write (*,*) 'Error: The constant is missing!'
        call exit(-1)
    end if
    
    ! Retrieve the constant and allocate the arrays on the CPU
    call get_command_argument(1, argv)
    READ (argv,*) a
    allocate(x(ARRAY_SIZE))
    allocate(y(ARRAY_SIZE))
    
    ! Initialize them with fixed values
    x = 0.1
    y = 0.2
    
    ! Allocate the arrays on the GPU and copy the content
    hr = cudaMalloc(d_x,    ARRAY_SIZE)
    hr = cudaMalloc(d_y,    ARRAY_SIZE)
    hr = cudaMemcpy(d_x, x, ARRAY_SIZE)
    hr = cudaMemcpy(d_y, y, ARRAY_SIZE)
    
    ! Call the CPU code
    call cpu_saxpy(ARRAY_SIZE, a, x, y)
    
    ! Calculate the "hash" of the result from the CPU
    call generate_hash(ARRAY_SIZE, y, error);
    
    ! Call the GPU code and copy back the result
    call gpu_saxpy<<<grid, block>>>(ARRAY_SIZE, a, d_x, d_y)

    hr = cudaMemcpy(y, d_y, ARRAY_SIZE)
    
    ! Calculate the "hash" of the result from the GPU
    call generate_hash(ARRAY_SIZE, y, error_gpu);
    
    error = abs(error - error_gpu)
    
    ! Confirm that the execution has finished
    write (*,*) 'Execution finished (error=', error, ').'
    
    if (error > 0.0001) then
        write (*,*) 'Error: The solution is incorrect!'
    end if
    
    ! Release all the allocations
    hr = cudaFree(d_x)
    hr = cudaFree(d_y)
    deallocate(x)
    deallocate(y)
end program lab01_ex2

